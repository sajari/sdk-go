/*
 * Sajari API
 *
 * Sajari is a smart, highly-configurable, real-time search service that enables thousands of businesses worldwide to provide amazing search experiences on their websites, stores, and applications.
 *
 * API version: v4beta1
 * Contact: support@sajari.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RecordsApiService RecordsApi service
type RecordsApiService service

type ApiBatchUpsertRecordsRequest struct {
	ctx                              _context.Context
	ApiService                       *RecordsApiService
	collectionId                     string
	v4beta1BatchUpsertRecordsRequest *V4beta1BatchUpsertRecordsRequest
}

func (r ApiBatchUpsertRecordsRequest) V4beta1BatchUpsertRecordsRequest(v4beta1BatchUpsertRecordsRequest V4beta1BatchUpsertRecordsRequest) ApiBatchUpsertRecordsRequest {
	r.v4beta1BatchUpsertRecordsRequest = &v4beta1BatchUpsertRecordsRequest
	return r
}

func (r ApiBatchUpsertRecordsRequest) Execute() (V4beta1BatchUpsertRecordsResponse, *_nethttp.Response, error) {
	return r.ApiService.BatchUpsertRecordsExecute(r)
}

/*
 * BatchUpsertRecords Batch upsert records
 * The batch version of the
[UpsertRecord](/docs/api-reference#operation/UpsertRecord) call.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection to upsert the records in, e.g. `my-collection`.
 * @return ApiBatchUpsertRecordsRequest
*/
func (a *RecordsApiService) BatchUpsertRecords(ctx _context.Context, collectionId string) ApiBatchUpsertRecordsRequest {
	return ApiBatchUpsertRecordsRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return V4beta1BatchUpsertRecordsResponse
 */
func (a *RecordsApiService) BatchUpsertRecordsExecute(r ApiBatchUpsertRecordsRequest) (V4beta1BatchUpsertRecordsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V4beta1BatchUpsertRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsApiService.BatchUpsertRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/records:batchUpsert"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v4beta1BatchUpsertRecordsRequest == nil {
		return localVarReturnValue, nil, reportError("v4beta1BatchUpsertRecordsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v4beta1BatchUpsertRecordsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRecordRequest struct {
	ctx                              _context.Context
	ApiService                       *RecordsApiService
	collectionId                     string
	sajariv4beta1DeleteRecordRequest *Sajariv4beta1DeleteRecordRequest
}

func (r ApiDeleteRecordRequest) Sajariv4beta1DeleteRecordRequest(sajariv4beta1DeleteRecordRequest Sajariv4beta1DeleteRecordRequest) ApiDeleteRecordRequest {
	r.sajariv4beta1DeleteRecordRequest = &sajariv4beta1DeleteRecordRequest
	return r
}

func (r ApiDeleteRecordRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.DeleteRecordExecute(r)
}

/*
 * DeleteRecord Delete record
 * Delete a record with the given key.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection that contains the record to delete, e.g. `my-collection`.
 * @return ApiDeleteRecordRequest
 */
func (a *RecordsApiService) DeleteRecord(ctx _context.Context, collectionId string) ApiDeleteRecordRequest {
	return ApiDeleteRecordRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *RecordsApiService) DeleteRecordExecute(r ApiDeleteRecordRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsApiService.DeleteRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/records:delete"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sajariv4beta1DeleteRecordRequest == nil {
		return localVarReturnValue, nil, reportError("sajariv4beta1DeleteRecordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sajariv4beta1DeleteRecordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordRequest struct {
	ctx                           _context.Context
	ApiService                    *RecordsApiService
	collectionId                  string
	sajariv4beta1GetRecordRequest *Sajariv4beta1GetRecordRequest
}

func (r ApiGetRecordRequest) Sajariv4beta1GetRecordRequest(sajariv4beta1GetRecordRequest Sajariv4beta1GetRecordRequest) ApiGetRecordRequest {
	r.sajariv4beta1GetRecordRequest = &sajariv4beta1GetRecordRequest
	return r
}

func (r ApiGetRecordRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetRecordExecute(r)
}

/*
 * GetRecord Get record
 * Retrieve a record with the given key.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection that contains the record to retrieve, e.g. `my-collection`.
 * @return ApiGetRecordRequest
 */
func (a *RecordsApiService) GetRecord(ctx _context.Context, collectionId string) ApiGetRecordRequest {
	return ApiGetRecordRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *RecordsApiService) GetRecordExecute(r ApiGetRecordRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsApiService.GetRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/records:get"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sajariv4beta1GetRecordRequest == nil {
		return localVarReturnValue, nil, reportError("sajariv4beta1GetRecordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sajariv4beta1GetRecordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpsertRecordRequest struct {
	ctx                        _context.Context
	ApiService                 *RecordsApiService
	collectionId               string
	v4beta1UpsertRecordRequest *V4beta1UpsertRecordRequest
}

func (r ApiUpsertRecordRequest) V4beta1UpsertRecordRequest(v4beta1UpsertRecordRequest V4beta1UpsertRecordRequest) ApiUpsertRecordRequest {
	r.v4beta1UpsertRecordRequest = &v4beta1UpsertRecordRequest
	return r
}

func (r ApiUpsertRecordRequest) Execute() (V4beta1UpsertRecordResponse, *_nethttp.Response, error) {
	return r.ApiService.UpsertRecordExecute(r)
}

/*
 * UpsertRecord Upsert record
 * If the record does not exist in your collection it is inserted. If it does
exist it is updated.

If no pipeline is specified, the default record pipeline is used to process
the record.

For example, to add a single product from your ecommerce store to a
collection, use the following call:

```json
{
  "pipeline": {
    "name": "my-pipeline",
    "version": "1"
  },
  "record": {
    "id": "54hdc7h2334h",
    "name": "Smart TV",
    "price": 1999,
    "brand": "Acme",
    "description": "...",
    "in_stock": true
  }
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection to upsert the record in, e.g. `my-collection`.
 * @return ApiUpsertRecordRequest
*/
func (a *RecordsApiService) UpsertRecord(ctx _context.Context, collectionId string) ApiUpsertRecordRequest {
	return ApiUpsertRecordRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return V4beta1UpsertRecordResponse
 */
func (a *RecordsApiService) UpsertRecordExecute(r ApiUpsertRecordRequest) (V4beta1UpsertRecordResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V4beta1UpsertRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsApiService.UpsertRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/records:upsert"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v4beta1UpsertRecordRequest == nil {
		return localVarReturnValue, nil, reportError("v4beta1UpsertRecordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v4beta1UpsertRecordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

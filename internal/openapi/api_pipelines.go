/*
 * Sajari API
 *
 * Sajari is a smart, highly-configurable, real-time search service that enables thousands of businesses worldwide to provide amazing search experiences on their websites, stores, and applications.
 *
 * API version: v4beta1
 * Contact: support@sajari.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PipelinesApiService PipelinesApi service
type PipelinesApiService service

type ApiCreatePipelineRequest struct {
	ctx                    _context.Context
	ApiService             *PipelinesApiService
	collectionId           string
	sajariv4beta1Pipeline1 *Sajariv4beta1Pipeline1
}

func (r ApiCreatePipelineRequest) Sajariv4beta1Pipeline1(sajariv4beta1Pipeline1 Sajariv4beta1Pipeline1) ApiCreatePipelineRequest {
	r.sajariv4beta1Pipeline1 = &sajariv4beta1Pipeline1
	return r
}

func (r ApiCreatePipelineRequest) Execute() (Sajariv4beta1Pipeline1, *_nethttp.Response, error) {
	return r.ApiService.CreatePipelineExecute(r)
}

/*
 * CreatePipeline Create pipeline
 * Create a new pipeline.

Pipelines are immutable once created. If you want to change a pipeline e.g.
to add or change some steps, you need to create a new version of that
pipeline.

To start using a new pipeline you need to update your record ingestion
calls and/or your query calls to specify the new pipeline.

To create the pipeline from YAML, set the request's `Content-Type` header
to `application/yaml` and submit the pipeline's YAML in the request body.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection to create the pipeline in, e.g. `my-collection`.
 * @return ApiCreatePipelineRequest
*/
func (a *PipelinesApiService) CreatePipeline(ctx _context.Context, collectionId string) ApiCreatePipelineRequest {
	return ApiCreatePipelineRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return Sajariv4beta1Pipeline1
 */
func (a *PipelinesApiService) CreatePipelineExecute(r ApiCreatePipelineRequest) (Sajariv4beta1Pipeline1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Sajariv4beta1Pipeline1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipeline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/pipelines"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sajariv4beta1Pipeline1 == nil {
		return localVarReturnValue, nil, reportError("sajariv4beta1Pipeline1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sajariv4beta1Pipeline1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneratePipelinesRequest struct {
	ctx                             _context.Context
	ApiService                      *PipelinesApiService
	collectionId                    string
	v4beta1GeneratePipelinesRequest *V4beta1GeneratePipelinesRequest
}

func (r ApiGeneratePipelinesRequest) V4beta1GeneratePipelinesRequest(v4beta1GeneratePipelinesRequest V4beta1GeneratePipelinesRequest) ApiGeneratePipelinesRequest {
	r.v4beta1GeneratePipelinesRequest = &v4beta1GeneratePipelinesRequest
	return r
}

func (r ApiGeneratePipelinesRequest) Execute() (V4beta1GeneratePipelinesResponse, *_nethttp.Response, error) {
	return r.ApiService.GeneratePipelinesExecute(r)
}

/*
 * GeneratePipelines Generate pipelines
 * Generate basic record, query and autocomplete pipeline templates.
Use these templates as a starting point for your collection's pipelines.

This call returns a set of pipelines that you can pass directly to the
create pipeline call.

The generated templates can be returned in JSON, the default, or YAML. To
return the generated pipelines in YAML, set the request's `Accept` header
to `application/yaml`. The three pipelines in the YAML response are
separated by three dashes (`---`).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection, e.g. `my-collection`.
 * @return ApiGeneratePipelinesRequest
*/
func (a *PipelinesApiService) GeneratePipelines(ctx _context.Context, collectionId string) ApiGeneratePipelinesRequest {
	return ApiGeneratePipelinesRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return V4beta1GeneratePipelinesResponse
 */
func (a *PipelinesApiService) GeneratePipelinesExecute(r ApiGeneratePipelinesRequest) (V4beta1GeneratePipelinesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V4beta1GeneratePipelinesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GeneratePipelines")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}:generatePipelines"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v4beta1GeneratePipelinesRequest == nil {
		return localVarReturnValue, nil, reportError("v4beta1GeneratePipelinesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v4beta1GeneratePipelinesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRequest struct {
	ctx          _context.Context
	ApiService   *PipelinesApiService
	collectionId string
	type_        string
	name         string
	version      string
	view         *string
}

func (r ApiGetPipelineRequest) View(view string) ApiGetPipelineRequest {
	r.view = &view
	return r
}

func (r ApiGetPipelineRequest) Execute() (Sajariv4beta1Pipeline1, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineExecute(r)
}

/*
 * GetPipeline Get pipeline
 * Retrieve the details of a pipeline. Supply the type, name and version.

To retrieve the pipeline in YAML, set the request's `Accept` header to
`application/yaml`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection that owns the pipeline, e.g. `my-collection`.
 * @param type_ The type of the pipeline to retrieve, either `record` or `query`.
 * @param name The name of the pipeline to retrieve, e.g. `my-pipeline`.
 * @param version The version of the pipeline to retrieve, e.g. `42`.
 * @return ApiGetPipelineRequest
*/
func (a *PipelinesApiService) GetPipeline(ctx _context.Context, collectionId string, type_ string, name string, version string) ApiGetPipelineRequest {
	return ApiGetPipelineRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
		type_:        type_,
		name:         name,
		version:      version,
	}
}

/*
 * Execute executes the request
 * @return Sajariv4beta1Pipeline1
 */
func (a *PipelinesApiService) GetPipelineExecute(r ApiGetPipelineRequest) (Sajariv4beta1Pipeline1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Sajariv4beta1Pipeline1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipeline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/pipelines/{type}/{name}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", _neturl.PathEscape(parameterToString(r.type_, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPipelinesRequest struct {
	ctx          _context.Context
	ApiService   *PipelinesApiService
	collectionId string
	pageSize     *int32
	pageToken    *string
	view         *string
}

func (r ApiListPipelinesRequest) PageSize(pageSize int32) ApiListPipelinesRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiListPipelinesRequest) PageToken(pageToken string) ApiListPipelinesRequest {
	r.pageToken = &pageToken
	return r
}
func (r ApiListPipelinesRequest) View(view string) ApiListPipelinesRequest {
	r.view = &view
	return r
}

func (r ApiListPipelinesRequest) Execute() (V4beta1ListPipelinesResponse, *_nethttp.Response, error) {
	return r.ApiService.ListPipelinesExecute(r)
}

/*
 * ListPipelines List pipelines
 * Retrieve a list of pipelines.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection that owns this set of pipelines, e.g. `my-collection`.
 * @return ApiListPipelinesRequest
 */
func (a *PipelinesApiService) ListPipelines(ctx _context.Context, collectionId string) ApiListPipelinesRequest {
	return ApiListPipelinesRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return V4beta1ListPipelinesResponse
 */
func (a *PipelinesApiService) ListPipelinesExecute(r ApiListPipelinesRequest) (V4beta1ListPipelinesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V4beta1ListPipelinesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.ListPipelines")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/pipelines"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDefaultPipelineRequest struct {
	ctx                              _context.Context
	ApiService                       *PipelinesApiService
	collectionId                     string
	v4beta1SetDefaultPipelineRequest *V4beta1SetDefaultPipelineRequest
}

func (r ApiSetDefaultPipelineRequest) V4beta1SetDefaultPipelineRequest(v4beta1SetDefaultPipelineRequest V4beta1SetDefaultPipelineRequest) ApiSetDefaultPipelineRequest {
	r.v4beta1SetDefaultPipelineRequest = &v4beta1SetDefaultPipelineRequest
	return r
}

func (r ApiSetDefaultPipelineRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SetDefaultPipelineExecute(r)
}

/*
 * SetDefaultPipeline Set default pipeline
 * Set the default pipeline for a collection.

Every collection has a default `record` pipeline and a default `query`
pipeline.

When a pipeline is required to complete an operation, it can be omitted
from the request if a default pipeline has been set. When adding a record
to a collection, the default `record` pipeline is used if none is provided.
When querying a collection, the default `query` pipeline is used if none is
provided.

Once a default pipeline has been set it cannot be cleared, only set to
another pipeline.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection to set the default query pipeline of, e.g. `my-collection`.
 * @return ApiSetDefaultPipelineRequest
*/
func (a *PipelinesApiService) SetDefaultPipeline(ctx _context.Context, collectionId string) ApiSetDefaultPipelineRequest {
	return ApiSetDefaultPipelineRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *PipelinesApiService) SetDefaultPipelineExecute(r ApiSetDefaultPipelineRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.SetDefaultPipeline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}:setDefaultPipeline"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v4beta1SetDefaultPipelineRequest == nil {
		return localVarReturnValue, nil, reportError("v4beta1SetDefaultPipelineRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v4beta1SetDefaultPipelineRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDefaultVersionRequest struct {
	ctx                             _context.Context
	ApiService                      *PipelinesApiService
	collectionId                    string
	type_                           string
	name                            string
	v4beta1SetDefaultVersionRequest *V4beta1SetDefaultVersionRequest
}

func (r ApiSetDefaultVersionRequest) V4beta1SetDefaultVersionRequest(v4beta1SetDefaultVersionRequest V4beta1SetDefaultVersionRequest) ApiSetDefaultVersionRequest {
	r.v4beta1SetDefaultVersionRequest = &v4beta1SetDefaultVersionRequest
	return r
}

func (r ApiSetDefaultVersionRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SetDefaultVersionExecute(r)
}

/*
 * SetDefaultVersion Set default pipeline version
 * Set the default version for a given pipeline.

The default version of a pipeline allows you to refer to a pipeline without
having to specify a version. This means you can change the pipeline version
used for requests without having to change your code.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId The collection that owns the pipeline to set the default version of, e.g. `my-collection`.
 * @param type_ The type of the pipeline to set the default version of, either `record` or `query`.
 * @param name The name of the pipeline to set the default version of, e.g. `my-pipeline`.
 * @return ApiSetDefaultVersionRequest
*/
func (a *PipelinesApiService) SetDefaultVersion(ctx _context.Context, collectionId string, type_ string, name string) ApiSetDefaultVersionRequest {
	return ApiSetDefaultVersionRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
		type_:        type_,
		name:         name,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *PipelinesApiService) SetDefaultVersionExecute(r ApiSetDefaultVersionRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.SetDefaultVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4beta1/collections/{collection_id}/pipelines/{type}/{name}:setDefaultVersion"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", _neturl.PathEscape(parameterToString(r.type_, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v4beta1SetDefaultVersionRequest == nil {
		return localVarReturnValue, nil, reportError("v4beta1SetDefaultVersionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v4beta1SetDefaultVersionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GatewayruntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
